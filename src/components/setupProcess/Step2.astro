---
import { t } from 'astro-i18n';
import AddProposals from "@components/process/AddProposals.astro";
import AddProposalsNoJS from "@components/process/AddProposalsNoJS.astro";
import EditProposalList from "@components/process/EditProposalList.astro";
import EditProposalListNoJS from "@components/process/EditProposalListNoJS.astro";
import TimeSelector from "@components/datetime/TimeSelector.astro";
import { adjustDates } from '@utils/dateAdjustments';
import TimeSelectorNoJS from '@components/datetime/TimeSelectorNoJS.astro';

type Props = {
  phase: string;
  proposalStartDate: number;
  proposalEndDate: number;
  votingStartDate: number;
  votingEndDate: number;
}
const { phase, proposalStartDate, proposalEndDate, votingStartDate, votingEndDate } = Astro.props;

const {
  pStart,
  pEnd,
  vStart,
  vEnd
} = adjustDates(phase, proposalStartDate, proposalEndDate, votingStartDate, votingEndDate);

---
<step-2 data-phase={phase}>
  <div id="step-2">
    { phase === "full" ? (
      <div>
        <h2 class="flex justify-center mt-4">{() => t('process.timeLeftHeading')}</h2>
        <br/>
        <noscript>
          <TimeSelectorNoJS phase="proposal" startDate={pStart} endDate={pEnd} startMinDate={new Date()}/>  
          <br/><br/>
          <TimeSelectorNoJS phase="voting" startDate={vStart} endDate={vEnd} startMinDate={pEnd}/>  
          <div class="flex justify-around mt-5">
            
            <form action="/api/update-step" method="POST">
              <input type="hidden" name="step" value="1"/>
              <button class="btn" type="submit">{() => t('buttons.back')}</button>
            </form>
            <form action='/api/update-step' method="POST">
              <input type="hidden" name="step" value="3" />
              <button class="btn btn-primary" type="submit">{() => t('buttons.continue')}</button>
            </form>
          </div>
        </noscript>
        <div class="js-content-block hidden">
          <TimeSelector phase="proposal" startDate={pStart} endDate={pEnd} startMinDate={new Date()}/>  
          <TimeSelector phase="voting" startDate={vStart} endDate={vEnd} startMinDate={pEnd}/>
        </div>
      </div>
    ) : phase === "voting" ? (
      <div>
        <noscript>
          <TimeSelectorNoJS phase="voting" startDate={vStart} endDate={vEnd} startMinDate={new Date()}/>
          <br/><br/>
          <EditProposalListNoJS />
          <br/>
          <AddProposalsNoJS />
          <div class="flex justify-around mt-5">
            <form action="/api/update-step" method="POST">
              <input type="hidden" name="step" value="1"/>
              <button class="btn" type="submit">{() => t('buttons.back')}</button>
            </form>
            <form action="/api/update-step" method="POST">
              <input type="hidden" name="step" value="3" />
              <button class="btn btn-primary" type="submit">{() => t('buttons.continue')}</button>
            </form>
          </div>
        </noscript>
        <div class="js-content-block hidden">
          <TimeSelector phase="voting" startDate={vStart} endDate={vEnd} startMinDate={new Date()}/>
          <br/>
          <h2>{ () => t('setup.proposals') }</h2>    
          <EditProposalList />
          <br/>
          <AddProposals />
        </div>
      </div>
    ) : null }
    <div class="justify-around mt-5 js-content-flex hidden">
      <button id="backButton" class="btn" type="submit">{() => t('buttons.back')}</button>
      <button id="continueButton" class="btn btn-primary" type="submit">{() => t('buttons.continue')}</button>
    </div>
  </div>
</step-2>


<script>
  import { sliderToDuration, durationToSlider } from '@utils/logslider';
  import { formatDuration, formatLocalDateTime } from '@utils/dateHelpers';
  const formElement = document.getElementById('step-2');
  if (formElement) {
    const adjustVotingPhaseDates = (originalProposalEndDate: Date, proposalEndDate: Date, step2Element: HTMLElement) => {
      const votingTimeSelector = step2Element.querySelector('[data-phase="voting"]');
      if (!votingTimeSelector) return;

      const querySelector = (selector: any) => votingTimeSelector.querySelector(selector);
      const votingStartPicker = querySelector('#start-date-picker-voting input[type="datetime-local"]') as HTMLInputElement;
      const votingEndPicker = querySelector('#end-date-picker-voting input[type="datetime-local"]') as HTMLInputElement;

      if (!votingStartPicker || !votingEndPicker) return; // Ensure elements exist

      const originalVotingDuration = new Date(votingEndPicker.value).getTime() - new Date(votingStartPicker.value).getTime();
      const adjustmentDuration = new Date(votingStartPicker.value).getTime() - originalProposalEndDate.getTime();

      const newVotingStartDate = new Date(proposalEndDate.getTime() + adjustmentDuration);
      const newVotingEndDate = new Date(newVotingStartDate.getTime() + originalVotingDuration);

      votingStartPicker.value = formatLocalDateTime(newVotingStartDate);
      votingEndPicker.value = formatLocalDateTime(newVotingEndDate);
    };

    const initDurationSlider = (durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement, affectVotingStart: boolean, step2Element: HTMLElement) => {
      if (durationSlider) {
        let originalEndDate = new Date(endPicker.value);

        durationSlider.addEventListener('input', (event: Event) => {
          const sliderValue = parseInt((event.target as HTMLInputElement).value, 10);
          const newDuration = sliderToDuration(sliderValue) * 60 * 1000;
          const newEndDate = new Date(new Date(startPicker.value).getTime() + newDuration);
          if (affectVotingStart) adjustVotingPhaseDates(originalEndDate, newEndDate, step2Element);
          originalEndDate = newEndDate;

          endPicker.value = formatLocalDateTime(newEndDate);
          durationDisplay.textContent = formatDuration(newDuration / 1000);
        });
        durationDisplay.textContent = formatDuration(sliderToDuration(parseInt(durationSlider.value, 10)) * 60 );

      } 
    }

    const updateDurationSlider = (durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement) => {
      if (durationSlider && startPicker && endPicker) {
        const newDuration = (+new Date(endPicker.value) - +new Date(startPicker.value)) / 1000;
        const sliderValue = durationToSlider(newDuration / 60);
        if (sliderValue) durationSlider.value = sliderValue.toString();
        durationDisplay.textContent = formatDuration(newDuration);
      }
    }

    const initDatetimePickers = (durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement, affectVotingStart: boolean, step2Element: HTMLElement) => {      
      if (startPicker && endPicker) {
        let originalStartDate = new Date(startPicker.value);
        let originalEndDate = new Date(endPicker.value);
        let originalDuration = originalEndDate.getTime() - originalStartDate.getTime();

        startPicker.addEventListener('change', (event: any) => {
          const newStartDate = new Date(event.target.value);
          if (isNaN(newStartDate.getTime())) return;
          
          let newEndDate = new Date(newStartDate.getTime() + originalDuration);
          if (newEndDate.getTime() - newStartDate.getTime() < 60000) {
            newEndDate = new Date(newStartDate.getTime() + 60000);
          }
          endPicker.value = formatLocalDateTime(newEndDate);
          endPicker.min = formatLocalDateTime(new Date(newStartDate.getTime() + 60000));
        });

        endPicker.addEventListener('change', (event: any) => {
          let newEndDate = new Date(event.target.value);
          if (isNaN(newEndDate.getTime())) return;
          if (affectVotingStart) adjustVotingPhaseDates(originalEndDate, newEndDate, step2Element);
          originalEndDate = newEndDate;
          originalDuration = originalEndDate.getTime() - originalStartDate.getTime();
          originalStartDate = new Date(startPicker.value);
          updateDurationSlider(durationSlider, startPicker, endPicker, durationDisplay);
        });
      }
    }
    class Step2 extends HTMLElement {
      phase: string = this.dataset.phase as string;
      constructor() {
        super();
        this.phase = this.dataset.phase || '';
        this.initialize();
      }

      initialize() {
        this.initializeTimeSelectors();
        this.setupEventListeners();
        this.displayJavaScriptContent();
      }

      setupEventListeners() {
        const backButton = this.querySelector('#backButton');
        const continueButton = this.querySelector('#continueButton');

        if (backButton) {
          backButton.addEventListener('click', (event) => this.handleBackButtonClick(event));
        }

        if (continueButton) {
          continueButton.addEventListener('click', (event) => this.handleContinueButtonClick(event));
        }
      }

      handleBackButtonClick(event: Event) {
        this.submitFormData('/api/update-step', { 'step': '1' });
      }

      handleContinueButtonClick(event: Event) {

        const formData = new FormData();
        formData.append('step', '2');

        if (this.phase === 'full') {
          this.appendInputValueToFormData(formData, 'start-date-picker-proposal');
          this.appendInputValueToFormData(formData, 'end-date-picker-proposal');
          this.appendInputValueToFormData(formData, 'start-date-picker-voting');
          this.appendInputValueToFormData(formData, 'end-date-picker-voting');
        }
        for (let [key, value] of formData.entries()) {
          console.log(`${key}: ${value}`);
        }
        this.submitFormData('/api/process-store', formData);
      }

      appendInputValueToFormData(formData: FormData, containerId: string) {
        const containerElement = this.querySelector(`#${containerId}`);
        if (containerElement) {
          const inputElement = containerElement.querySelector('input');
          if (inputElement && inputElement.value) {
            formData.append(containerId, inputElement.value);
          } else {
            console.log(`Input not found inside container #${containerId}`);
          }
        } else {
          console.log(`Container #${containerId} not found`);
        }
      }

      submitFormData(url: string, formData: any) {
        fetch(url, {
          method: 'POST',
          body: formData
        }).then(response => {
          if (response.ok) {
            window.location.reload();
          } else {
            console.error('Error in submission');
          }
        }).catch(error => {
          console.error('Error sending request', error);
        });
      }

      displayJavaScriptContent() {
        const jsContentBlocks = this.querySelectorAll('.js-content-block, .js-content-flex') as NodeListOf<HTMLElement>;
        jsContentBlocks.forEach((content) => {
          content.style.display = content.classList.contains('js-content-flex') ? 'flex' : 'block';
        });
      }

      initializeTimeSelectors() {
        const timeSelectors = this.querySelectorAll('.time-selector') as NodeListOf<Element>;
        timeSelectors.forEach(selector => {
          const phaseMode = selector.getAttribute('data-phase');

          const startPickerId = `#start-date-picker-${phaseMode}`;
          const endPickerId = `#end-date-picker-${phaseMode}`;
          const sliderId = `#datetime-slider-${phaseMode}`;

          const startPicker = selector.querySelector(startPickerId)?.querySelector('input[type="datetime-local"]') as HTMLInputElement;
          const endPicker = selector.querySelector(endPickerId)?.querySelector('input[type="datetime-local"]') as HTMLInputElement;
          const durationSlider = selector.querySelector(sliderId)?.querySelector('input[type="range"]') as HTMLInputElement;
          const durationDisplay = selector.querySelector(sliderId)?.querySelector('.duration-display') as HTMLElement;
          const affectVotingStart = (this.phase === 'full' && phaseMode === 'proposal') ? true : false;
          initDatetimePickers(durationSlider, startPicker, endPicker, durationDisplay, affectVotingStart, this);
          initDurationSlider(durationSlider, startPicker, endPicker, durationDisplay, affectVotingStart, this);
        });
      }
    }
    customElements.define('step-2', Step2);
  }
</script>
