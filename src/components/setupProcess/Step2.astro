---
import { Translator } from '@utils/i18n.js';

import ProposalsList from "@components/process/ProposalsList.astro";
import TimeSelector from "@components/datetime/TimeSelector.astro";
import TimezoneSelector from "@components/datetime/TimezoneSelector.astro";
import { adjustDates } from '@utils/dateAdjustments';
import IProposal from '@interfaces/IProposal';

const translator = new Translator(Astro.currentLocale || 'en');
await translator.init();

type Props = {
  phase: string;
  proposals: Array<IProposal>;
  proposalStartDate: number;
  proposalEndDate: number;
  votingStartDate: number;
  votingEndDate: number;
  timezone: string;
}
const { phase, proposalStartDate, proposalEndDate, votingStartDate, votingEndDate, proposals, timezone } = Astro.props;

const {
  pStart,
  pEnd,
  vStart,
  vEnd
} = adjustDates(phase, proposalStartDate, proposalEndDate, votingStartDate, votingEndDate);

if (proposals && proposals.length > 0) {
  proposals.forEach(proposal => proposal.editing = true);
}
---
<step-2 data-phase={phase} data-timezone={timezone}>
  <div id="step-2">
    { phase === "full" ? (
      <div>
        <h2 class="flex  mt-4">{translator.t('setup.timeLeftHeading')}</h2>
        <TimezoneSelector/>
        <br/>
        <noscript>
          <TimeSelector nojs phase="proposal" startDate={pStart} endDate={pEnd} startMinDate={new Date()} timezone={timezone}/>  
          <br/><br/>
          <TimeSelector nojs phase="voting" startDate={vStart} endDate={vEnd} startMinDate={pEnd} timezone={timezone}/>  
          <div class="flex justify-around mt-5">
            <form action="/api/update-step" method="POST">
              <input type="hidden" name="step" value="1"/>
              <button class="btn" type="submit">{translator.t('buttons.back')}</button>
            </form>
            <form action='/api/update-step' method="POST">
              <input type="hidden" name="step" value="3" />
              <button class="btn btn-primary" type="submit">{translator.t('buttons.continue')}</button>
            </form>
          </div>
        </noscript>
        <div class="js-content-block hidden">
          <TimeSelector phase="proposal" startDate={pStart} endDate={pEnd} startMinDate={new Date()} timezone={timezone}/>  
          <TimeSelector phase="voting" startDate={vStart} endDate={vEnd} startMinDate={pEnd} timezone={timezone}/>
        </div>
      </div>
    ) : phase === "voting" ? (
      <div>
        <h2 class="flex mt-4">{translator.t('setup.timeLeftVotingHeading')}</h2>
        <TimezoneSelector/>

        <br/>
        <noscript>
          <TimeSelector nojs hideTitle phase="voting" startDate={vStart} endDate={vEnd} startMinDate={new Date()} timezone={timezone}/>
          <br/><br/>
          <h2>{ translator.t('setup.proposals') }</h2>    
          <ProposalsList nojs isSetup={true} proposals={proposals}/>
          <br/>
          <div class="flex justify-around mt-5">
            <form action="/api/update-step" method="POST">
              <input type="hidden" name="step" value="1"/>
              <button class="btn" type="submit">{translator.t('buttons.back')}</button>
            </form>
            <form action="/api/update-step" method="POST">
              <input type="hidden" name="step" value="3" />
              <button class="btn btn-primary" type="submit">{translator.t('buttons.continue')}</button>
            </form>
          </div>
        </noscript>
        <div class="js-content-block hidden">
          <TimeSelector hideTitle phase="voting" startDate={vStart} endDate={vEnd} startMinDate={new Date()} timezone={timezone}/>
          <br/>
          <h2>{ translator.t('setup.proposals') }</h2>    
          <ProposalsList proposals={proposals}/>
          <div id="errorMessage" class="text-red-500 mt-4 hidden">{translator.t('setup.errorMinProposals')}</div>
        </div>
      </div>
    ) : null }
      <div class="justify-around mt-5 js-content-flex hidden">
        <button id="backButton" class="btn" type="submit">{translator.t('buttons.back')}</button>
        <button id="continueButton" class="btn btn-primary disabled" type="submit">{translator.t('buttons.continue')}</button>
      </div>
  </div>
</step-2>


<script>
  import { sliderToDuration, durationToSlider } from '@utils/logslider';
  import { formatDuration, formatDateInTimezone } from '@utils/dateUtils';
  import IProposal from '@interfaces/IProposal';
  import { utcToZonedTime, zonedTimeToUtc } from 'date-fns-tz';
  import { adjustVotingPhaseDates } from '@utils/dateAdjustments';

  const formElement = document.getElementById('step-2');

  if (formElement) {
    const timezone = formElement.getAttribute('data-timezone') || 'UTC';

    const initDurationSlider = (durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement, affectVotingStart: boolean, step2Element: HTMLElement) => {
      if (durationSlider) {
        let originalEndDate = utcToZonedTime(new Date(endPicker.value), timezone);

        durationSlider.addEventListener('input', (event: Event) => {
          const sliderValue = parseInt((event.target as HTMLInputElement).value, 10);
          const newDuration = sliderToDuration(sliderValue) * 60 * 1000;
          const newEndDate = utcToZonedTime(new Date(utcToZonedTime(new Date(startPicker.value), timezone).getTime() + newDuration), timezone);
          if (affectVotingStart) adjustVotingPhaseDates(originalEndDate, newEndDate, step2Element, timezone);
          originalEndDate = newEndDate;

          endPicker.value = formatDateInTimezone(newEndDate.getTime(), timezone);
          durationDisplay.textContent = formatDuration(newDuration / 1000);
        });
        durationDisplay.textContent = formatDuration(sliderToDuration(parseInt(durationSlider.value, 10)) * 60);
      }
    };

    const updateDurationSlider = (durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement) => {
      if (durationSlider && startPicker && endPicker) {
        const newDuration = (utcToZonedTime(new Date(endPicker.value), timezone).getTime() - utcToZonedTime(new Date(startPicker.value), timezone).getTime()) / 1000;
        const sliderValue = durationToSlider(newDuration / 60);
        if (sliderValue) durationSlider.value = sliderValue.toString();
        durationDisplay.textContent = formatDuration(newDuration);
      }
    };

    const initDatetimePickers = (durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement, affectVotingStart: boolean, step2Element: HTMLElement) => {
      if (startPicker && endPicker) {
        let originalStartDate = utcToZonedTime(new Date(startPicker.value), timezone);
        let originalEndDate = utcToZonedTime(new Date(endPicker.value), timezone);
        let originalDuration = originalEndDate.getTime() - originalStartDate.getTime();

        startPicker.addEventListener('change', (event: any) => {
          const newStartDate = utcToZonedTime(new Date(event.target.value), timezone);
          if (isNaN(newStartDate.getTime())) return;

          let newEndDate = utcToZonedTime(new Date(newStartDate.getTime() + originalDuration), timezone);
          if (newEndDate.getTime() - newStartDate.getTime() < 60000) {
            newEndDate = utcToZonedTime(new Date(newStartDate.getTime() + 60000), timezone);
          }
          endPicker.value = formatDateInTimezone(newEndDate.getTime(), timezone);
          endPicker.min = formatDateInTimezone(utcToZonedTime(new Date(newStartDate.getTime() + 60000), timezone).getTime(), timezone);
        });

        endPicker.addEventListener('change', (event: any) => {
          let newEndDate = utcToZonedTime(new Date(event.target.value), timezone);
          if (isNaN(newEndDate.getTime())) return;
          if (affectVotingStart) adjustVotingPhaseDates(originalEndDate, newEndDate, step2Element, timezone);
          originalEndDate = newEndDate;
          originalDuration = originalEndDate.getTime() - originalStartDate.getTime();
          originalStartDate = utcToZonedTime(new Date(startPicker.value), timezone);
          updateDurationSlider(durationSlider, startPicker, endPicker, durationDisplay);
        });
      }
    };

    class Step2 extends HTMLElement {
      phase: string = this.dataset.phase as string;
      timezone: string = this.dataset.timezone || 'UTC';

      constructor() {
        super();
        this.phase = this.dataset.phase || '';
        this.initialize();
      }

      initialize() {
        this.initializeTimeSelectors();
        this.setupEventListeners();
        this.displayJavaScriptContent();
        this.initializeTimezoneSelector();
        this.updateContinueButton();

      }

      initializeTimezoneSelector() {
    const timezoneSelect = this.querySelector('#timezone-select') as HTMLSelectElement;
    if (timezoneSelect) {
      timezoneSelect.value = this.timezone;
      timezoneSelect.addEventListener('change', () => {
        this.timezone = timezoneSelect.value;
        this.updateTimeSelectors();
      });
    }
  }

  updateTimeSelectors() {
    const timeSelectors = this.querySelectorAll('.time-selector') as NodeListOf<Element>;
    timeSelectors.forEach(selector => {
      const phaseMode = selector.getAttribute('data-phase');

      const startPickerId = `#start-date-picker-${phaseMode}`;
      const endPickerId = `#end-date-picker-${phaseMode}`;
      const sliderId = `#datetime-slider-${phaseMode}`;

      const startPicker = selector.querySelector(startPickerId)?.querySelector('input[type="datetime-local"]') as HTMLInputElement;
      const endPicker = selector.querySelector(endPickerId)?.querySelector('input[type="datetime-local"]') as HTMLInputElement;
      const durationSlider = selector.querySelector(sliderId)?.querySelector('input[type="range"]') as HTMLInputElement;
      const durationDisplay = selector.querySelector(sliderId)?.querySelector('.duration-display') as HTMLElement;

      if (startPicker && endPicker) {
        const startDate = utcToZonedTime(new Date(startPicker.value), this.timezone);
        const endDate = utcToZonedTime(new Date(endPicker.value), this.timezone);

        startPicker.value = formatDateInTimezone(startDate.getTime(), this.timezone);
        endPicker.value = formatDateInTimezone(endDate.getTime(), this.timezone);

        if (durationSlider && durationDisplay) {
          const duration = (endDate.getTime() - startDate.getTime()) / 1000;
          const sliderValue = durationToSlider(duration / 60);
          if (sliderValue) durationSlider.value = sliderValue.toString();
          durationDisplay.textContent = formatDuration(duration);
        }
      }
    });
  }
      setupEventListeners() {
        const backButton = this.querySelector('#backButton');
        const continueButton = this.querySelector('#continueButton');

        if (backButton) {
          backButton.addEventListener('click', (event) => this.handleBackButtonClick(event));
        }

        if (continueButton) {
          continueButton.addEventListener('click', (event) => this.handleContinueButtonClick(event));
        }
      }

      handleBackButtonClick(event: Event) {
        const formData = new FormData();
        formData.append('step', '1');

        this.submitFormData('/api/update-step', formData);
      }

      handleContinueButtonClick(event: Event) {
        const formData = new FormData();
        formData.append('step', '2');

        if (this.phase === 'full') {
          this.appendInputValueToFormData(formData, 'start-date-picker-proposal');
          this.appendInputValueToFormData(formData, 'end-date-picker-proposal');
          this.appendInputValueToFormData(formData, 'start-date-picker-voting');
          this.appendInputValueToFormData(formData, 'end-date-picker-voting');
        } else if (this.phase === 'voting') {
          this.appendInputValueToFormData(formData, 'start-date-picker-voting');
          this.appendInputValueToFormData(formData, 'end-date-picker-voting');

          const proposals: IProposal[] = [];
          const proposalElements = document.querySelectorAll('.proposal .flex');
          
          proposalElements.forEach((proposalElement: Element) => {
            const id = proposalElement.id;
            const titleInput: HTMLInputElement | null = proposalElement.querySelector('input[type="text"]');
            const descriptionDiv: HTMLElement | null = proposalElement.querySelector('div[id^="description-"]');
            const quillOpsInput: HTMLInputElement | null = proposalElement.querySelector('input[type="hidden"]');
            if (id && titleInput) {
              proposals.push({
                id,
                title: titleInput.value,
                description: descriptionDiv?.innerText
              });
            }
            
          })
          formData.append('proposals', JSON.stringify(proposals));
        }

        formData.append('timezone', this.timezone);
        this.submitFormData('/api/process-store', formData);
      }

      appendInputValueToFormData(formData: FormData, containerId: string) {
        const containerElement = this.querySelector(`#${containerId}`);
        if (containerElement) {
          const inputElement = containerElement.querySelector('input');
          if (inputElement && inputElement.value) {
            const date = new Date(inputElement.value);
            const utcTimestamp = zonedTimeToUtc(date, this.timezone).getTime();
            formData.append(containerId, utcTimestamp.toString());
          } else {
            console.log(`Input not found inside container #${containerId}`);
          }
        } else {
          console.log(`Container #${containerId} not found`);
        }
      }


      submitFormData(url: string, formData: any) {
        fetch(url, {
          method: 'POST',
          body: formData,
        })
          .then((response) => {
            if (response.ok) {
              window.location.reload();
            } else {
              response.text().then((errorMessage) => {
                const errorElement = this.querySelector('#errorMessage') as HTMLElement;
                errorElement.classList.remove('hidden');
              });
            }
          })
          .catch((error) => {
            console.error('Error sending request', error);
          });
      }
      updateContinueButton() {
        const continueButton = this.querySelector('#continueButton') as HTMLButtonElement;
        const proposals = document.querySelectorAll('.proposal .flex');

        if (proposals.length >= 2) {
          continueButton.classList.remove('disabled');
        } else {
          continueButton.classList.add('disabled');
        }
      }


      displayJavaScriptContent() {
        const jsContentBlocks = this.querySelectorAll('.js-content-block, .js-content-flex') as NodeListOf<HTMLElement>;
        jsContentBlocks.forEach((content) => {
          content.style.display = content.classList.contains('js-content-flex') ? 'flex' : 'block';
        });
      }
      initializeTimeSelectors() {
        const timeSelectors = this.querySelectorAll('.time-selector') as NodeListOf<Element>;
        timeSelectors.forEach(selector => {
          const phaseMode = selector.getAttribute('data-phase');

          const startPickerId = `#start-date-picker-${phaseMode}`;
          const endPickerId = `#end-date-picker-${phaseMode}`;
          const sliderId = `#datetime-slider-${phaseMode}`;

          const startPicker = selector.querySelector(startPickerId)?.querySelector('input[type="datetime-local"]') as HTMLInputElement;
          const endPicker = selector.querySelector(endPickerId)?.querySelector('input[type="datetime-local"]') as HTMLInputElement;
          const durationSlider = selector.querySelector(sliderId)?.querySelector('input[type="range"]') as HTMLInputElement;
          const durationDisplay = selector.querySelector(sliderId)?.querySelector('.duration-display') as HTMLElement;
          const affectVotingStart = (this.phase === 'full' && phaseMode === 'proposal') ? true : false;
          initDatetimePickers(durationSlider, startPicker, endPicker, durationDisplay, affectVotingStart, this);
          initDurationSlider(durationSlider, startPicker, endPicker, durationDisplay, affectVotingStart, this);
        });
      }
    }
    customElements.define('step-2', Step2);
  }
</script>
