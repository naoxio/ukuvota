---
import { t } from 'astro-i18n';
import AddProposals from "@components/process/AddProposals.astro";
import EditProposalList from "@components/process/EditProposalList.astro";
import TimeSelector from "@components/datetime/TimeSelector.astro";
import { adjustDates } from '@utils/dateAdjustments';
import TimeSelectorNoJS from '@components/datetime/TimeSelectorNoJS.astro';

type Props = {
  phase: string;
  proposalStartDate: number;
  proposalEndDate: number;
  votingStartDate: number;
  votingEndDate: number;
}
const { phase, proposalStartDate, proposalEndDate, votingStartDate, votingEndDate } = Astro.props;

const {
  pStart,
  pEnd,
  vStart,
  vEnd
} = adjustDates(phase, proposalStartDate, proposalEndDate, votingStartDate, votingEndDate);

---
<step-2 data-phase={phase}>
  <form id="step-2" action='/api/process-store' method="POST">
    <input type="hidden" name="step" value="2" />

    { phase === "full" ? (
      <div>
        <h2 class="flex justify-center mt-4">{() => t('process.timeLeftHeading')}</h2>
        <br/>
        <noscript>
          <TimeSelectorNoJS phase="proposal" startDate={pStart} endDate={pEnd} startMinDate={new Date()}/>  
          <br/><br/>
          <TimeSelectorNoJS phase="voting" startDate={vStart} endDate={vEnd} startMinDate={pEnd}/>  
        </noscript>
        <div class="js-content hidden">
          <TimeSelectorNoJS phase="proposal" startDate={pStart} endDate={pEnd} startMinDate={new Date()}/>  
          <TimeSelectorNoJS phase="voting" startDate={vStart} endDate={vEnd} startMinDate={pEnd}/>
        </div>
      </div>
    ) : phase === "voting" ? ( 
      <div>
        <h2>{() => t('setup.selectTimeForVoting')}</h2>
        <br/>
        <TimeSelector phase="voting" startDate={vStart} endDate={vEnd} startMinDate={new Date()}/>
        <br/>
        <h2>{ () => t('setup.proposals') }</h2>    
        <EditProposalList />
        <br/>
        <AddProposals />
      </div>
    ) : null }
    <br/>
    <noscript>
      <form action='/api/update-step' method="POST">
        <input type="hidden" name="step" value="3" />
        <div class="flex justify-around mt-5">
          <button class="btn btn-primary" type="submit">{() => t('buttons.continue')}</button>
        </div>
      </form>
    </noscript>
    <div class="flex justify-around mt-5">
      <button class="btn btn-primary" type="submit">{() => t('buttons.continue')}</button>
    </div>
  </form>
  <div class="flex justify-around mt-5">
    <form action="/api/update-step" method="POST">
      <input type="hidden" name="step" value="1"/>
      <button class="btn" type="submit">{() => t('buttons.back')}</button>
    </form>
  </div>
</step-2>


<script>
  const step2Element: HTMLElement | null = document.querySelector('step-2');
  if (step2Element) {
    const form: HTMLFormElement = document.createElement('form');
    form.id = 'step-2';
    form.method = 'POST';
    form.action = '/api/process-store';

    const hiddenInput: HTMLInputElement = document.createElement('input');
    hiddenInput.type = 'hidden';
    hiddenInput.name = 'step';
    hiddenInput.value = '2';
    form.appendChild(hiddenInput);

    Array.from(step2Element.children).forEach(child => {
      if (child.tagName !== 'FORM') {
        form.appendChild(child);
      }
    });

    step2Element.appendChild(form);
  }

  const js_content = document.querySelectorAll('.js-content') as NodeListOf<HTMLElement>;
  js_content.forEach((content: HTMLElement) => {
    content.style.display = 'block'; 
  });

  import { sliderToDuration, durationToSlider } from '@utils/logslider';
  import { formatDuration, formatLocalDateTime } from '@utils/dateHelpers';
  const formElement = document.getElementById('step-2');
  if (formElement) {


    const adjustVotingPhaseDates = (originalProposalEndDate: Date, proposalEndDate: Date, step2Element: HTMLElement) => {
      const votingTimeSelector = step2Element.querySelector('[data-phase="voting"]');
      if (!votingTimeSelector) return;

      const querySelector = (selector: any) => votingTimeSelector.querySelector(selector);
      const votingStartPicker = querySelector('#start-date-picker-voting input[type="datetime-local"]') as HTMLInputElement;
      const votingEndPicker = querySelector('#end-date-picker-voting input[type="datetime-local"]') as HTMLInputElement;

      if (!votingStartPicker || !votingEndPicker) return; // Ensure elements exist

      const originalVotingDuration = new Date(votingEndPicker.value).getTime() - new Date(votingStartPicker.value).getTime();
      const adjustmentDuration = new Date(votingStartPicker.value).getTime() - originalProposalEndDate.getTime();

      const newVotingStartDate = new Date(proposalEndDate.getTime() + adjustmentDuration);
      const newVotingEndDate = new Date(newVotingStartDate.getTime() + originalVotingDuration);

      votingStartPicker.value = formatLocalDateTime(newVotingStartDate);
      votingEndPicker.value = formatLocalDateTime(newVotingEndDate);
    };

    const initDurationSlider = (durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement, affectVotingStart: boolean, step2Element: HTMLElement) => {
      if (durationSlider) {
        let originalEndDate = new Date(endPicker.value);

        durationSlider.addEventListener('input', (event: Event) => {
          const sliderValue = parseInt((event.target as HTMLInputElement).value, 10);
          const newDuration = sliderToDuration(sliderValue) * 60 * 1000;
          const newEndDate = new Date(new Date(startPicker.value).getTime() + newDuration);
          if (affectVotingStart) adjustVotingPhaseDates(originalEndDate, newEndDate, step2Element);
          originalEndDate = newEndDate;

          endPicker.value = formatLocalDateTime(newEndDate);
          durationDisplay.textContent = formatDuration(newDuration / 1000);
        });
        durationDisplay.textContent = formatDuration(sliderToDuration(parseInt(durationSlider.value, 10)) * 60 );

      } 
    }

    const updateDurationSlider = (durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement) => {
      if (durationSlider && startPicker && endPicker) {
        const newDuration = (+new Date(endPicker.value) - +new Date(startPicker.value)) / 1000;
        const sliderValue = durationToSlider(newDuration / 60);
        if (sliderValue) durationSlider.value = sliderValue.toString();
        durationDisplay.textContent = formatDuration(newDuration);
      }
    }

    const initDatetimePickers = (durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement, affectVotingStart: boolean, step2Element: HTMLElement) => {      
        if (startPicker && endPicker) {
          let originalStartDate = new Date(startPicker.value);
          let originalEndDate = new Date(endPicker.value);
          let originalDuration = originalEndDate.getTime() - originalStartDate.getTime();

          startPicker.addEventListener('change', (event: any) => {
            const newStartDate = new Date(event.target.value);
            if (isNaN(newStartDate.getTime())) return;
            
            let newEndDate = new Date(newStartDate.getTime() + originalDuration);
            if (newEndDate.getTime() - newStartDate.getTime() < 60000) {
              newEndDate = new Date(newStartDate.getTime() + 60000);
            }
            endPicker.value = formatLocalDateTime(newEndDate);
            endPicker.min = formatLocalDateTime(new Date(newStartDate.getTime() + 60000));
          });

          endPicker.addEventListener('change', (event: any) => {
            let newEndDate = new Date(event.target.value);
            if (isNaN(newEndDate.getTime())) return;
            if (affectVotingStart) adjustVotingPhaseDates(originalEndDate, newEndDate, step2Element);
            originalEndDate = newEndDate;
            originalDuration = originalEndDate.getTime() - originalStartDate.getTime();
            originalStartDate = new Date(startPicker.value);
            updateDurationSlider(durationSlider, startPicker, endPicker, durationDisplay);
          });
        }
      }

    class Step2 extends HTMLElement {
      phaseMode: string= this.dataset.phase || '';
      constructor() {
        super();
        this.initializeTimeSelectors();
      }

      initializeTimeSelectors() {
        const timeSelectors = this.querySelectorAll('.time-selector') as NodeListOf<Element>;
        timeSelectors.forEach(selector => {
          const phase = selector.getAttribute('data-phase');

          const startPickerId = `#start-date-picker-${phase}`;
          const endPickerId = `#end-date-picker-${phase}`;
          const sliderId = `#datetime-slider-${phase}`;

          const startPicker = selector.querySelector(startPickerId)?.querySelector('input[type="datetime-local"]') as HTMLInputElement;
          const endPicker = selector.querySelector(endPickerId)?.querySelector('input[type="datetime-local"]') as HTMLInputElement;
          const durationSlider = selector.querySelector(sliderId)?.querySelector('input[type="range"]') as HTMLInputElement;
          const durationDisplay = selector.querySelector(sliderId)?.querySelector('.duration-display') as HTMLElement;
          const affectVotingStart = (this.phaseMode === 'full' && phase === 'proposal') ? true : false;
          initDatetimePickers(durationSlider, startPicker, endPicker, durationDisplay, affectVotingStart, this);
          initDurationSlider(durationSlider, startPicker, endPicker, durationDisplay, affectVotingStart, this);
        });
      }
    }

    customElements.define('step-2', Step2);
  }
</script>
