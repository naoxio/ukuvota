---
import { Translator } from '@utils/i18n.js';
import ProposalsList from "@components/process/ProposalsList.astro";
import TimeSelector from "@components/datetime/TimeSelector.astro";
import TimezoneSelector from "@components/datetime/TimezoneSelector.astro";
import { adjustDates } from '@utils/dateAdjustments';
import IProposal from '@interfaces/IProposal';

const translator = new Translator(Astro.currentLocale || 'en');

type Props = {
  phase: string;
  proposals: Array<IProposal>;
  proposalStartDate: number;
  proposalEndDate: number;
  votingStartDate: number;
  votingEndDate: number;
}

const { phase, proposalStartDate, proposalEndDate, votingStartDate, votingEndDate, proposals } = Astro.props;

const { pStart, pEnd, vStart, vEnd } = adjustDates(phase, proposalStartDate, proposalEndDate, votingStartDate, votingEndDate);

if (proposals && proposals.length > 0) {
  proposals.forEach(proposal => proposal.editing = true);
}
---

<step-2 data-phase={phase} class="step-container">
  <div id="step-2" class="step-content">
    <div class="phase-container">
      <h2 class="section-heading">{phase === "full" ? translator.t('setup.timeLeftHeading') : translator.t('setup.timeLeftVotingHeading')}</h2>
      <TimezoneSelector />
      <br />
      {phase === "full" ? (
        <div>
          <TimeSelector phase="proposal" startDate={pStart} endDate={pEnd} startMinDate={new Date()} />  
          <TimeSelector phase="voting" startDate={vStart} endDate={vEnd} startMinDate={pEnd} />
        </div>
      ) : (
        <div>
          <TimeSelector hideTitle phase="voting" startDate={vStart} endDate={vEnd} startMinDate={new Date()} />
          <br />
          <h2 class="section-heading">{translator.t('setup.proposals')}</h2>    
          <ProposalsList proposals={proposals} isSetup/>
          <div id="errorMessage" class="error-message hidden">{translator.t('setup.errorMinProposals')}</div>
        </div>
      )}
    </div>
    <div class="button-container">
      <button id="backButton" class="button secondary" type="submit">{translator.t('buttons.back')}</button>
      <button id="continueButton" class="button primary disabled" type="submit">{translator.t('buttons.continue')}</button>
    </div>
  </div>
</step-2>

<style>
  .step-container {
    margin-bottom: 2rem;
  }

  .step-content {
    max-width: 600px;
    margin: 0 auto;
  }

  .phase-container {
    margin-bottom: 1.5rem;
  }

  .section-heading {
    font-size: 1.5rem;
    font-weight: bold;
    margin-bottom: 1rem;
  }

  .hidden {
    display: none;
  }

  .error-message {
    color: #ff0000;
    margin-top: 1rem;
  }

  .button-container {
    display: flex;
    justify-content: space-between;
    margin-top: 1.5rem;
  }
</style>

<script>
  import { sliderToDuration, durationToSlider } from '@utils/logslider';
  import { formatDuration, formatDateInTimezone } from '@utils/dateUtils';
  import IProposal from '@interfaces/IProposal';
  import { utcToZonedTime, zonedTimeToUtc } from 'date-fns-tz';
  import { adjustVotingPhaseDates } from '@utils/dateAdjustments';
  import localforage from 'localforage';

  const storedTimeZone = await localforage.getItem('userTimezone') || Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';

  class Step2 extends HTMLElement {
    phase = this.dataset.phase || '';
    timezone = storedTimeZone as string;
    
    constructor() {
      super();
      this.initialize();
    }

    initialize() {
      this.initializeTimeSelectors();
      this.setupEventListeners();
      this.initializeTimezoneSelector();
      this.updateContinueButton();
    }

    initializeTimezoneSelector() {
      const timezoneSelect = this.querySelector('#timezone-select') as HTMLSelectElement;
      if (timezoneSelect) {
        timezoneSelect.value = this.timezone;
        timezoneSelect.addEventListener('change', async () => {
          this.timezone = timezoneSelect.value;
          await localforage.setItem('userTimezone', this.timezone);
          this.updateTimeSelectors();
        });
      }
    }

    updateTimeSelectors() {
      const timeSelectors = this.querySelectorAll('.time-selector') as NodeListOf<Element>;
      timeSelectors.forEach(selector => {
        const phaseMode = selector.getAttribute('data-phase');
        const startPicker = selector.querySelector(`#start-date-picker-${phaseMode} input[type="datetime-local"]`) as HTMLInputElement;
        const endPicker = selector.querySelector(`#end-date-picker-${phaseMode} input[type="datetime-local"]`) as HTMLInputElement;
        const durationSlider = selector.querySelector(`#datetime-slider-${phaseMode} input[type="range"]`) as HTMLInputElement;
        const durationDisplay = selector.querySelector(`#datetime-slider-${phaseMode} .duration-display`) as HTMLElement;

        if (startPicker && endPicker) {
          const startDate = utcToZonedTime(new Date(startPicker.value), this.timezone);
          const endDate = utcToZonedTime(new Date(endPicker.value), this.timezone);

          startPicker.value = formatDateInTimezone(startDate.getTime(), this.timezone);
          endPicker.value = formatDateInTimezone(endDate.getTime(), this.timezone);

          if (durationSlider && durationDisplay) {
            const duration = (endDate.getTime() - startDate.getTime()) / 1000;
            const sliderValue = durationToSlider(duration / 60);
            if (sliderValue) durationSlider.value = sliderValue.toString();
            durationDisplay.textContent = formatDuration(duration);
          }
        }
      });
    }

    setupEventListeners() {
      const backButton = this.querySelector('#backButton');
      const continueButton = this.querySelector('#continueButton');

      if (backButton) {
        backButton.addEventListener('click', (event) => this.handleBackButtonClick(event));
      }

      if (continueButton) {
        continueButton.addEventListener('click', (event) => this.handleContinueButtonClick(event));
      }

      // Add event listener for proposal changes
      const proposalsList = this.querySelector('proposals-list');
      if (proposalsList) {
        proposalsList.addEventListener('proposalsUpdated', () => this.updateContinueButton());
      }
    }

    handleBackButtonClick(event: Event) {
      const formData = new FormData();
      formData.append('step', '1');
      this.submitFormData('/api/update-step', formData);
    }

    handleContinueButtonClick(event: Event) {
      if ((event.target as HTMLButtonElement).classList.contains('disabled')) {
        return;
      }

      const formData = new FormData();
      formData.append('step', '2');

      if (this.phase === 'full') {
        this.appendInputValueToFormData(formData, 'start-date-picker-proposal');
        this.appendInputValueToFormData(formData, 'end-date-picker-proposal');
        this.appendInputValueToFormData(formData, 'start-date-picker-voting');
        this.appendInputValueToFormData(formData, 'end-date-picker-voting');
      } else if (this.phase === 'voting') {
        this.appendInputValueToFormData(formData, 'start-date-picker-voting');
        this.appendInputValueToFormData(formData, 'end-date-picker-voting');
        this.appendProposalsToFormData(formData);
      }

      formData.append('timezone', this.timezone);
      this.submitFormData('/api/process-store', formData);
    }

    appendInputValueToFormData(formData: FormData, containerId: string) {
      const inputElement = this.querySelector(`#${containerId} input`) as HTMLInputElement;
      if (inputElement && inputElement.value) {
        const date = new Date(inputElement.value);
        const utcTimestamp = zonedTimeToUtc(date, this.timezone).getTime();
        formData.append(containerId, utcTimestamp.toString());
      }
    }

    appendProposalsToFormData(formData: FormData) {
      const proposals: IProposal[] = [];
      const proposalElements = this.querySelectorAll('.proposal .flex');
      
      proposalElements.forEach((proposalElement: Element) => {
        const id = proposalElement.id;
        const titleInput = proposalElement.querySelector('input[type="text"]') as HTMLInputElement;
        const descriptionDiv = proposalElement.querySelector('div[id^="description-"]') as HTMLElement;
        
        if (id && titleInput) {
          proposals.push({
            id,
            title: titleInput.value
          });

          if (descriptionDiv) {
            const descriptionId = `description_${id}`;
            localforage.setItem(descriptionId, descriptionDiv.innerText);
          }
        }
      });

      formData.append('proposals', JSON.stringify(proposals));
    }

    submitFormData(url: string, formData: any) {
      fetch(url, {
        method: 'POST',
        body: formData,
      })
        .then((response) => {
          if (response.ok) {
            window.location.reload();
          } else {
            response.text().then((errorMessage) => {
              const errorElement = this.querySelector('#errorMessage') as HTMLElement;
              errorElement.classList.remove('hidden');
            });
          }
        })
        .catch((error) => {
          console.error('Error sending request', error);
        });
    }

    updateContinueButton() {
      const continueButton = this.querySelector('#continueButton') as HTMLButtonElement;
      const proposals = this.querySelectorAll('.proposal .flex');
      const allTimeSelectorsValid = this.checkTimeSelectors();

      if ((this.phase === 'voting' && proposals.length >= 2) || (this.phase === 'full' && allTimeSelectorsValid)) {
        continueButton.classList.remove('disabled');
      } else {
        continueButton.classList.add('disabled');
      }
    }

    checkTimeSelectors() {
      const timeSelectors = this.querySelectorAll('.time-selector') as NodeListOf<Element>;
      return Array.from(timeSelectors).every(selector => {
        const phaseMode = selector.getAttribute('data-phase');
        const startPicker = selector.querySelector(`#start-date-picker-${phaseMode} input[type="datetime-local"]`) as HTMLInputElement;
        const endPicker = selector.querySelector(`#end-date-picker-${phaseMode} input[type="datetime-local"]`) as HTMLInputElement;
        return startPicker && endPicker && startPicker.value && endPicker.value;
      });
    }

    initializeTimeSelectors() {
      const timeSelectors = this.querySelectorAll('.time-selector') as NodeListOf<Element>;
      timeSelectors.forEach(selector => {
        const phaseMode = selector.getAttribute('data-phase');
        const startPicker = selector.querySelector(`#start-date-picker-${phaseMode} input[type="datetime-local"]`) as HTMLInputElement;
        const endPicker = selector.querySelector(`#end-date-picker-${phaseMode} input[type="datetime-local"]`) as HTMLInputElement;
        const durationSlider = selector.querySelector(`#datetime-slider-${phaseMode} input[type="range"]`) as HTMLInputElement;
        const durationDisplay = selector.querySelector(`#datetime-slider-${phaseMode} .duration-display`) as HTMLElement;
        const affectVotingStart = (this.phase === 'full' && phaseMode === 'proposal');

        this.initDatetimePickers(durationSlider, startPicker, endPicker, durationDisplay, affectVotingStart);
        this.initDurationSlider(durationSlider, startPicker, endPicker, durationDisplay, affectVotingStart);
      });
    }

    initDatetimePickers(durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement, affectVotingStart: boolean) {
      if (startPicker && endPicker) {
        let originalStartDate = utcToZonedTime(new Date(startPicker.value), this.timezone);
        let originalEndDate = utcToZonedTime(new Date(endPicker.value), this.timezone);
        let originalDuration = originalEndDate.getTime() - originalStartDate.getTime();

        startPicker.addEventListener('change', (event: any) => {
          const newStartDate = utcToZonedTime(new Date(event.target.value), this.timezone);
          if (isNaN(newStartDate.getTime())) return;

          let newEndDate = utcToZonedTime(new Date(newStartDate.getTime() + originalDuration), this.timezone);
          if (newEndDate.getTime() - newStartDate.getTime() < 60000) {
            newEndDate = utcToZonedTime(new Date(newStartDate.getTime() + 60000), this.timezone);
          }
          endPicker.value = formatDateInTimezone(newEndDate.getTime(), this.timezone);
          endPicker.min = formatDateInTimezone(utcToZonedTime(new Date(newStartDate.getTime() + 60000), this.timezone).getTime(), this.timezone);
          this.updateContinueButton();
        });

        endPicker.addEventListener('change', (event: any) => {
          let newEndDate = utcToZonedTime(new Date(event.target.value), this.timezone);
          if (isNaN(newEndDate.getTime())) return;
          if (affectVotingStart) adjustVotingPhaseDates(originalEndDate, newEndDate, this, this.timezone);
          originalEndDate = newEndDate;
          originalDuration = originalEndDate.getTime() - originalStartDate.getTime();
          originalStartDate = utcToZonedTime(new Date(startPicker.value), this.timezone);
          this.updateDurationSlider(durationSlider, startPicker, endPicker, durationDisplay);
          this.updateContinueButton();
        });
      }
    }

    initDurationSlider(durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement, affectVotingStart: boolean) {
      if (durationSlider) {
        let originalEndDate = utcToZonedTime(new Date(endPicker.value), this.timezone);

        durationSlider.addEventListener('input', (event: Event) => {
          const sliderValue = parseInt((event.target as HTMLInputElement).value, 10);
          const newDuration = sliderToDuration(sliderValue) * 60 * 1000;
          const newEndDate = utcToZonedTime(new Date(utcToZonedTime(new Date(startPicker.value), this.timezone).getTime() + newDuration), this.timezone);
          if (affectVotingStart) adjustVotingPhaseDates(originalEndDate, newEndDate, this, this.timezone);
          originalEndDate = newEndDate;

          endPicker.value = formatDateInTimezone(newEndDate.getTime(), this.timezone);
          durationDisplay.textContent = formatDuration(newDuration / 1000);
        });
        durationDisplay.textContent = formatDuration(sliderToDuration(parseInt(durationSlider.value, 10)) * 60);
      }
    }

    updateDurationSlider(durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement) {
      if (durationSlider && startPicker && endPicker) {
        const newDuration = (utcToZonedTime(new Date(endPicker.value), this.timezone).getTime() - utcToZonedTime(new Date(startPicker.value), this.timezone).getTime()) / 1000;
        const sliderValue = durationToSlider(newDuration / 60);
        if (sliderValue) durationSlider.value = sliderValue.toString();
        durationDisplay.textContent = formatDuration(newDuration);
      }
    }
  }

  customElements.define('step-2', Step2);
</script>