---
import { Translator } from '@utils/i18n.js';
import ProposalsList from "@components/process/ProposalsList.astro";
import TimeSelector from "@components/datetime/TimeSelector.astro";
import TimezoneSelector from "@components/datetime/TimezoneSelector.astro";
import { adjustDates } from '@utils/dateAdjustments';
import IProposal from '@interfaces/IProposal';

const translator = new Translator(Astro.currentLocale || 'en');


type Props = {
  phase: string;
  proposals: Array<IProposal>;
  proposalStartDate: number;
  proposalEndDate: number;
  votingStartDate: number;
  votingEndDate: number;
}

const { phase, proposalStartDate, proposalEndDate, votingStartDate, votingEndDate, proposals } = Astro.props;

const { pStart, pEnd, vStart, vEnd } = adjustDates(phase, proposalStartDate, proposalEndDate, votingStartDate, votingEndDate);

if (proposals && proposals.length > 0) {
  proposals.forEach(proposal => proposal.editing = true);
}
---

<step-2 data-phase={phase} >
  <div id="step-2">
    {phase === "full" ? (
      <div>
        <h2 class="flex mt-4">{translator.t('setup.timeLeftHeading')}</h2>
        <TimezoneSelector />
        <br />
        <div>
          <TimeSelector phase="proposal" startDate={pStart} endDate={pEnd} startMinDate={new Date()} />  
          <TimeSelector phase="voting" startDate={vStart} endDate={vEnd} startMinDate={pEnd} />
        </div>
      </div>
    ) : phase === "voting" ? (
      <div>
        <h2 class="flex mt-4">{translator.t('setup.timeLeftVotingHeading')}</h2>
        <TimezoneSelector />
        <br />
        <div>
          <TimeSelector hideTitle phase="voting" startDate={vStart} endDate={vEnd} startMinDate={new Date()} />
          <br />
          <h2>{translator.t('setup.proposals')}</h2>    
          <ProposalsList proposals={proposals} isSetup/>
          <div id="errorMessage" class="text-red-500 mt-4 hidden">{translator.t('setup.errorMinProposals')}</div>
        </div>
      </div>
    ) : null}
    <div class="justify-around mt-5 flex">
      <button id="backButton" class="btn" type="submit">{translator.t('buttons.back')}</button>
      <button id="continueButton" class="btn btn-primary disabled" type="submit">{translator.t('buttons.continue')}</button>
    </div>
  </div>
</step-2>

<script>
  import { sliderToDuration, durationToSlider } from '@utils/logslider';
  import { formatDuration, formatDateInTimezone } from '@utils/dateUtils';
  import IProposal from '@interfaces/IProposal';
  import { utcToZonedTime, zonedTimeToUtc } from 'date-fns-tz';
  import { adjustVotingPhaseDates } from '@utils/dateAdjustments';
  import localforage from 'localforage';

  const storedTimeZone = await localforage.getItem('userTimezone') || Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
  class Step2 extends HTMLElement {
    phase = this.dataset.phase || '';
    timezone = 'UTC'


    async fetchAndSetTimezone() {
      const storedTimeZone = await localforage.getItem('userTimezone') || Intl.DateTimeFormat().resolvedOptions().timeZone;
      this.timezone = storedTimeZone as string;
    }

    constructor() {
      super();
      this.initialize();
    }

    initialize() {

      this.fetchAndSetTimezone().then(() => {
        this.initializeTimezoneSelector();

        this.initializeTimeSelectors();
        this.setupEventListeners();
        this.updateContinueButton();
      });
    }

    initializeTimezoneSelector() {
      const timezoneSelect = this.querySelector('#timezone-select') as HTMLSelectElement;
      if (timezoneSelect) {
        timezoneSelect.value = this.timezone ;
        timezoneSelect.addEventListener('change', async () => {
          this.timezone = timezoneSelect.value;
          await localforage.setItem('userTimezone', this.timezone);
          this.updateTimeSelectors();

        });
      }
    }

    initializeTimeSelectors() {
      const timeSelectors = this.querySelectorAll('.time-selector') as NodeListOf<Element>;
      timeSelectors.forEach(selector => {
        const phaseMode = selector.getAttribute('data-phase');
        const startPicker = selector.querySelector(`#start-date-picker-${phaseMode} input[type="datetime-local"]`) as HTMLInputElement;
        const endPicker = selector.querySelector(`#end-date-picker-${phaseMode} input[type="datetime-local"]`) as HTMLInputElement;
        const durationSlider = selector.querySelector(`#datetime-slider-${phaseMode} input[type="range"]`) as HTMLInputElement;
        const durationDisplay = selector.querySelector(`#datetime-slider-${phaseMode} .duration-display`) as HTMLElement;
        const affectVotingStart = (this.phase === 'full' && phaseMode === 'proposal');
        this.initDatetimePickers(durationSlider, startPicker, endPicker, durationDisplay, affectVotingStart);
        this.initDurationSlider(durationSlider, startPicker, endPicker, durationDisplay, affectVotingStart);
      });
    }
    initDatetimePickers(durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement, affectVotingStart: boolean) {
      if (startPicker && endPicker) {
        let originalStartDate = zonedTimeToUtc(new Date(startPicker.value), this.timezone);
        let originalEndDate = zonedTimeToUtc(new Date(endPicker.value), this.timezone);
        let originalDuration = originalEndDate.getTime() - originalStartDate.getTime();
        startPicker.addEventListener('change', (event: any) => {
          const newStartDate = zonedTimeToUtc(new Date(event.target.value), this.timezone);
          const currentDate = new Date();

          if (newStartDate < currentDate || isNaN(newStartDate.getTime())) return;
          let newEndDate = new Date(newStartDate.getTime() + originalDuration);
          if (newEndDate.getTime() - newStartDate.getTime() < 60000) {
            newEndDate = new Date(newStartDate.getTime() + 60000);
            originalDuration = 60000;
          }
          
          originalStartDate = newStartDate;
          endPicker.value = formatDateInTimezone(utcToZonedTime(newEndDate, this.timezone).getTime(), this.timezone);
          endPicker.min = formatDateInTimezone(utcToZonedTime(new Date(newStartDate.getTime() + 60000), this.timezone).getTime(), this.timezone);
        });

        endPicker.addEventListener('change', (event: any) => {
          const newEndDate = zonedTimeToUtc(new Date(event.target.value), this.timezone);
          const currentDate = new Date();

          if (newEndDate < currentDate || newEndDate < originalStartDate || isNaN(newEndDate.getTime())) return;
          originalEndDate = newEndDate;
          originalDuration = originalEndDate.getTime() - originalStartDate.getTime();
          if (affectVotingStart) {
            adjustVotingPhaseDates(utcToZonedTime(originalEndDate, this.timezone), utcToZonedTime(newEndDate, this.timezone), this, this.timezone);
          }

          endPicker.min = formatDateInTimezone(utcToZonedTime(new Date(originalStartDate.getTime() + 60000), this.timezone).getTime(), this.timezone);
          this.updateDurationSlider(durationSlider, startPicker, endPicker, durationDisplay);
        });
      }
    }
    initDurationSlider(durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement, affectVotingStart: boolean) {
      if (durationSlider) {
        let originalEndDate = new Date(endPicker.value);
        durationSlider.addEventListener('input', (event: Event) => {
          const sliderValue = parseInt((event.target as HTMLInputElement).value, 10);
          const newDuration = sliderToDuration(sliderValue) * 60 * 1000;
          const newStartDate = new Date(startPicker.value);
          const newEndDate = new Date(newStartDate.getTime() + newDuration);
          if (affectVotingStart) {
            adjustVotingPhaseDates(utcToZonedTime(originalEndDate, this.timezone), utcToZonedTime(newEndDate, this.timezone), this, this.timezone);
          }
          originalEndDate = newEndDate;
          endPicker.value = formatDateInTimezone(utcToZonedTime(newEndDate, this.timezone).getTime(), this.timezone);
          durationDisplay.textContent = formatDuration(newDuration / 1000);
        });
        durationDisplay.textContent = formatDuration(sliderToDuration(parseInt(durationSlider.value, 10)) * 60);
      }
    }
    updateTimeSelectors() {
  const timeSelectors = this.querySelectorAll('.time-selector') as NodeListOf<Element>;
  const currentDate = new Date();

  timeSelectors.forEach(selector => {
    const phaseMode = selector.getAttribute('data-phase');
    const startPicker = selector.querySelector(`#start-date-picker-${phaseMode} input[type="datetime-local"]`) as HTMLInputElement;
    const endPicker = selector.querySelector(`#end-date-picker-${phaseMode} input[type="datetime-local"]`) as HTMLInputElement;
    const durationSlider = selector.querySelector(`#datetime-slider-${phaseMode} input[type="range"]`) as HTMLInputElement;
    const durationDisplay = selector.querySelector(`#datetime-slider-${phaseMode} .duration-display`) as HTMLElement;

    if (startPicker && endPicker) {
      let startDate = zonedTimeToUtc(new Date(startPicker.value), this.timezone);
      let endDate = zonedTimeToUtc(new Date(endPicker.value), this.timezone);
      const affectVotingStart = (phaseMode === 'proposal' && this.phase === 'full');

      // Ensure start date is not earlier than current date
      if (startDate < currentDate) {
        const duration = endDate.getTime() - startDate.getTime();
        startDate = new Date(currentDate.getTime());
        endDate = new Date(startDate.getTime() + duration);
      }

      // If phasemode is "proposal" and the phase is "full", adjust voting phase dates
      if (affectVotingStart) {
        const votingStartPicker = this.querySelector('#start-date-picker-voting input[type="datetime-local"]') as HTMLInputElement;
        const newVotingStartDate = new Date(endDate.getTime() + 60000); // Add 1 minute after proposal end date
        const votingEndPicker = this.querySelector('#end-date-picker-voting input[type="datetime-local"]') as HTMLInputElement;
        const votingStartDate = zonedTimeToUtc(new Date(votingStartPicker.value), this.timezone);
        const votingEndDate = zonedTimeToUtc(new Date(votingEndPicker.value), this.timezone);
        const votingDuration = votingEndDate.getTime() - votingStartDate.getTime();

        const newVotingEndDate = new Date(newVotingStartDate.getTime() + votingDuration);
        votingStartPicker.value = formatDateInTimezone(utcToZonedTime(newVotingStartDate, this.timezone).getTime(), this.timezone);
        votingEndPicker.value = formatDateInTimezone(utcToZonedTime(newVotingEndDate, this.timezone).getTime(), this.timezone);
      }

      const setPickerValue = (picker: HTMLInputElement, date: Date, timezone: string) => {
        picker.value = formatDateInTimezone(utcToZonedTime(date, timezone).getTime(), timezone);
      };

      setPickerValue(startPicker, startDate, this.timezone);
      setPickerValue(endPicker, endDate, this.timezone);

      if (durationSlider && durationDisplay) {
        const duration = (endDate.getTime() - startDate.getTime()) / 1000;
        const sliderValue = durationToSlider(duration / 60);
        if (sliderValue) durationSlider.value = sliderValue.toString();
        durationDisplay.textContent = formatDuration(duration);
      }
    }
  });
}
    setupEventListeners() {
      const backButton = this.querySelector('#backButton');
      const continueButton = this.querySelector('#continueButton');

      if (backButton) {
        backButton.addEventListener('click', (event) => this.handleBackButtonClick(event));
      }

      if (continueButton) {
        continueButton.addEventListener('click', (event) => this.handleContinueButtonClick(event));
      }
    }

    handleBackButtonClick(event: Event) {
      const formData = new FormData();
      formData.append('step', '1');
      this.submitFormData('/api/update-step', formData);
    }

    handleContinueButtonClick(event: Event) {
      const formData = new FormData();
      formData.append('step', '2');

      if (this.phase === 'full') {
        this.appendInputValueToFormData(formData, 'start-date-picker-proposal');
        this.appendInputValueToFormData(formData, 'end-date-picker-proposal');
        this.appendInputValueToFormData(formData, 'start-date-picker-voting');
        this.appendInputValueToFormData(formData, 'end-date-picker-voting');
      } else if (this.phase === 'voting') {
        this.appendInputValueToFormData(formData, 'start-date-picker-voting');
        this.appendInputValueToFormData(formData, 'end-date-picker-voting');
        this.appendProposalsToFormData(formData);
      }

      formData.append('timezone', this.timezone);
      this.submitFormData('/api/process-store', formData);
    }

    appendInputValueToFormData(formData: FormData, containerId: string) {
      const inputElement = this.querySelector(`#${containerId} input`) as HTMLInputElement;
      if (inputElement && inputElement.value) {
        const date = new Date(inputElement.value);
        const utcTimestamp = zonedTimeToUtc(date, this.timezone).getTime();
        formData.append(containerId, utcTimestamp.toString());
      }
    }

    appendProposalsToFormData(formData: FormData) {
      const proposals: IProposal[] = [];
      const proposalElements = this.querySelectorAll('.proposal .flex');
      
      proposalElements.forEach((proposalElement: Element) => {
        const id = proposalElement.id;
        const titleInput = proposalElement.querySelector('input[type="text"]') as HTMLInputElement;
        const descriptionDiv = proposalElement.querySelector('div[id^="description-"]') as HTMLElement;
        
        if (id && titleInput) {
          proposals.push({
            id,
            title: titleInput.value
          });

          if (descriptionDiv) {
            const descriptionId = `description_${id}`;
            localforage.setItem(descriptionId, descriptionDiv.innerText);
          }
        }
      });

      formData.append('proposals', JSON.stringify(proposals));
    }

    submitFormData(url: string, formData: any) {
      fetch(url, {
        method: 'POST',
        body: formData,
      })
        .then((response) => {
          if (response.ok) {
            window.location.reload();
          } else {
            response.text().then((errorMessage) => {
              const errorElement = this.querySelector('#errorMessage') as HTMLElement;
              errorElement.classList.remove('hidden');
            });
          }
        })
        .catch((error) => {
          console.error('Error sending request', error);
        });
    }

    updateContinueButton() {
      const continueButton = this.querySelector('#continueButton') as HTMLButtonElement;
      const proposals = this.querySelectorAll('.proposal .flex');

      if (proposals.length >= 2) {
        continueButton.classList.remove('disabled');
      } else {
        continueButton.classList.add('disabled');
      }
    }


    updateDurationSlider(durationSlider: HTMLInputElement, startPicker: HTMLInputElement, endPicker: HTMLInputElement, durationDisplay: HTMLElement) {
      if (durationSlider && startPicker && endPicker) {
        const startDate = new Date(startPicker.value);
        const endDate = new Date(endPicker.value);
        const newDuration = (endDate.getTime() - startDate.getTime()) / 1000;
        const sliderValue = durationToSlider(newDuration / 60);
        if (sliderValue) durationSlider.value = sliderValue.toString();
        durationDisplay.textContent = formatDuration(newDuration);
      }
    }
  }

  customElements.define('step-2', Step2);
</script>